#!/usr/bin/env python3
import requests
import time
import hmac
import hashlib
import base64
from google.oauth2.service_account import Credentials
from googleapiclient.discovery import build

# Kraken API credentials
API_KEY = "loByXGZWMMcFB50+AVHLKPK0PzHYzOUcRdgWeahmq3m019PdSMsZ1nCf"
API_SECRET = "av2egSlcsrqwtZyaToB6H4VXzCvfBmbsw+FIhUwnhP+ydw0/5edfXYspYUrU8Y3sGI7PyPvBH1V9e+PoDv6jGg=="
SHEET_ID = "1-tr1lmkFNDj4vOID5ASx21-CKzRq1cr0mudyJOHBszM"  # From Google Sheets URL
CREDENTIALS_FILE = "~/skripts/skripts-py/accounting/mbay-tax-sheet-for-kryptos-7fc01e35fb9a.json"

# Google Sheets setup
SCOPES = ["https://www.googleapis.com/auth/spreadsheets"]
creds = Credentials.from_service_account_file(CREDENTIALS_FILE, scopes=SCOPES)
service = build("sheets", "v4", credentials=creds)

# Kraken API request function
def kraken_request(endpoint, data=None):
    url = f"https://api.kraken.com/0/private/{endpoint}"
    if data is None:
        data = {}
    data["nonce"] = str(int(time.time() * 1000))

    # Create the signature
    post_data = "&".join([f"{k}={v}" for k, v in data.items()])
    encoded = (str(data["nonce"]) + post_data).encode()
    message = f"/0/private/{endpoint}".encode() + hashlib.sha256(encoded).digest()
    signature = hmac.new(base64.b64decode(API_SECRET), message, hashlib.sha512)
    sig = base64.b64encode(signature.digest()).decode()

    headers = {
        "API-Key": API_KEY,
        "API-Sign": sig,
    }
    response = requests.post(url, headers=headers, data=data)
    if response.status_code != 200 or "error" in response.json() and response.json()["error"]:
        raise Exception(f"API error: {response.json().get('error', 'Unknown error')}")
    return response.json()

# Fetch trade history
def get_trades():
    trades = []
    result = kraken_request("TradesHistory")
    trades.extend(result["result"]["trades"].values())
    return trades

# Fetch ledger (deposits, withdrawals, fees)
def get_ledger():
    ledger = []
    result = kraken_request("Ledgers")
    ledger.extend(result["result"]["ledger"].values())
    return ledger

# Process data for German tax declaration with FIFO
def process_for_tax(trades, ledger):
    tax_data = []
    headers = ["Date", "Type", "Asset", "Amount", "Buy Price (EUR)", "Sell Price (EUR)", "Gain/Loss (EUR)", "Fee (EUR)", "Notes"]
    tax_data.append(headers)

    # Sort trades by time for FIFO
    trades = sorted(trades, key=lambda x: float(x["time"]))
    holdings = {}  # {asset: [(amount, buy_price, timestamp)]}

    # Process trades
    for trade in trades:
        date = time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(float(trade["time"])))
        asset = trade["pair"][:3] if trade["pair"].startswith(("XBT", "ETH")) else trade["pair"][-3:]  # Handle pairs like XBTUSD or USDXBT
        amount = float(trade["vol"])
        price_eur = float(trade["price"])  # Assumes price in EUR or needs conversion
        fee_eur = float(trade["fee"])
        timestamp = float(trade["time"])

        if trade["type"] == "buy":
            if asset not in holdings:
                holdings[asset] = []
            holdings[asset].append((amount, price_eur, timestamp))
            tax_data.append([date, "Buy", asset, amount, price_eur, "", "", fee_eur, trade["ordertxid"]])
        else:  # Sell
            if asset in holdings and holdings[asset]:
                remaining = amount
                gain_loss = 0
                buy_price_used = 0
                while remaining > 0 and holdings[asset]:
                    buy_amount, buy_price, buy_time = holdings[asset][0]
                    if buy_amount <= remaining:
                        # Full sale of this batch
                        gain_loss += (price_eur - buy_price) * buy_amount
                        remaining -= buy_amount
                        buy_price_used = buy_price
                        holdings[asset].pop(0)
                    else:
                        # Partial sale
                        gain_loss += (price_eur - buy_price) * remaining
                        buy_price_used = buy_price
                        holdings[asset][0] = (buy_amount - remaining, buy_price, buy_time)
                        remaining = 0
                # Check if sale is taxable (within 1 year)
                if timestamp - buy_time < 365 * 24 * 3600:  # 1-year holding period
                    tax_data.append([date, "Sell", asset, amount, buy_price_used, price_eur, gain_loss, fee_eur, trade["ordertxid"]])
                else:
                    tax_data.append([date, "Sell (Tax-Free)", asset, amount, buy_price_used, price_eur, 0, fee_eur, trade["ordertxid"]])

    # Process ledger entries
    for entry in ledger:
        date = time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(float(entry["time"])))
        entry_type = entry["type"].capitalize()
        asset = entry["asset"]
        amount = float(entry["amount"])
        fee_eur = float(entry["fee"])
        tax_data.append([date, entry_type, asset, amount, "", "", "", fee_eur, entry["refid"]])

    return tax_data

# Write to Google Sheets
def write_to_sheets(data):
    body = {"values": data}
    service.spreadsheets().values().clear(
        spreadsheetId=SHEET_ID,
        range="Sheet1!A:Z",
    ).execute()
    service.spreadsheets().values().update(
        spreadsheetId=SHEET_ID,
        range="Sheet1!A1",
        valueInputOption="RAW",
        body=body
    ).execute()

# Main execution
def main():
    try:
        print("Fetching Kraken trade history...")
        trades = get_trades()
        print(f"Retrieved {len(trades)} trades.")

        print("Fetching Kraken ledger data...")
        ledger = get_ledger()
        print(f"Retrieved {len(ledger)} ledger entries.")

        print("Processing data for German tax declaration with FIFO...")
        tax_data = process_for_tax(trades, ledger)

        print("Writing to Google Sheets...")
        write_to_sheets(tax_data)
        print(f"Tax report written to Google Sheet: https://docs.google.com/spreadsheets/d/{SHEET_ID}")

    except Exception as e:
        print(f"Error: {str(e)}")

if __name__ == "__main__":
    main()
