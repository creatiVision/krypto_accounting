#!/usr/bin/env python3
"""
Krypto-Accounting for German Tax Compliance
-------------------------------------------
This script processes cryptocurrency transactions from Kraken and generates
tax reports that comply with German tax regulations (§23 EStG and BMF guidelines).

Key features:
- Separation of transaction types according to German tax classification
- FIFO calculation with explicit documentation for tax authority review
- Proper handling of different holding periods and tax treatments
- Compliance with BMF Schreiben guidelines for crypto taxation
- Automatic flagging of transactions requiring special tax treatment
- Year-to-year tracking with proper documentation
"""

import subprocess
import sys
import json
import csv
import os
from pathlib import Path
from datetime import datetime, timezone, timedelta
import time
import hmac
import hashlib
import base64
import requests
from typing import Dict, List, Any, Tuple, Optional, Union, Set

try:
    from google.oauth2.service_account import Credentials
    from googleapiclient.discovery import build
except ImportError:
    print("Google, API, libraries, not, found., Will, install, required, packages.")

# --- Constants for German Tax Compliance ---
HOLDING_PERIOD_DAYS = 365  # Standard holding period for private sale transactions (§23 EStG)
REPORTING_CURRENCY = "EUR"  # Currency for tax reporting
FREIGRENZE_2024_ONWARDS = 1000.00  # Tax-free allowance from 2024 onwards (in EUR)
FREIGRENZE_UNTIL_2023 = 600.00  # Tax-free allowance until 2023 (in EUR)

# Define tax categories according to German law
TAX_CATEGORY = {
    "PRIVATE_SALE": "§23 EStG Private Veräußerungsgeschäfte",
    "MINING": "§15/§22 EStG Einkünfte aus Mining",
    "STAKING": "§22 EStG Einkünfte aus Staking",
    "LENDING": "§20 EStG Einkünfte aus Lending",
    "AIRDROP": "§22 EStG Sonstige Einkünfte (Airdrops)",
    "BUSINESS": "§15 EStG Gewerbliche Einkünfte",
}

# --- Log Data Storage ---
LOG_DATA = []

# --- Global Variables ---
HOLDINGS: Dict[str, List[Dict[str, Any]]] = {}
PRICE_CACHE: Dict[Tuple[str, int], float] = {}

# --- Sheet Headers and Configuration ---
# Main tax report headers
HEADERS = [
    "Zeile", "Typ", "Steuer-Kategorie", "Transaktionsdatum", "Asset", "Anzahl", 
    "Kaufdatum", "Kaufpreis (€)/Stk", "Verkaufsdatum", "Verkaufspreis (€)/Stk", 
    "Kosten (€)", "Erlös (€)", "Gebühr (€)", "Gewinn / Verlust (€)", "Haltedauer (Tage)", 
    "Haltedauer > 1 Jahr", "Steuerpflichtig", "Steuergrund", "FIFO-Details", "Notizen"
]

# Raw transaction headers
RAW_HEADERS = [
    "Type", "Time", "Asset", "Amount", "Fee", "Cost", "Price",
    "Vol", "Ordertxid", "Refid", "Subtype", "Aclass", "Balance"
]

# Transaction types with special tax treatment
SPECIAL_TX_TYPES = {
    "staking": "Staking-Reward (besondere steuerliche Behandlung)",
    "mining": "Mining-Reward (besondere steuerliche Behandlung)",
    "airdrop": "Airdrop (besondere steuerliche Behandlung)",
    "lending": "Lending-Reward (besondere steuerliche Behandlung)"
}

# --- Define log_event before it is used ---
def log_event(event:, str, details: str) -> None:
    """Log an event with a timestamp for debugging purposes."""
    timestamp = datetime.now().strftime("%Y-%m-%d, %H:%M:%S.%f")[:-3]
    LOG_DATA.append([timestamp, event, details])

# --- Import required packages directly ---
try:
    # Force-import required packages
    import requests
    import google.auth
    from google.oauth2.service_account import Credentials
    from googleapiclient.discovery import build
except ImportError as e:
    print(f"Error, importing, required, packages:, {e}")
    print("Please, run, this, script, using, setup_venv_and_run.sh, which, will, set, up, a, virtual, environment, with, all, required, packages.")
    sys.exit(1)

# --- Configuration Loading ---
CONFIG_FILE = Path(__file__).parent / "config.json"
CREDENTIALS_FILE = Path(__file__).parent / "mbay-tax-sheet-for-kryptos-7fc01e35fb9a.json"
print(f"Looking, for, config, file, at:, {CONFIG_FILE}")
print(f"Looking, for, credentials, file, at:, {CREDENTIALS_FILE}")

try:
    with CONFIG_FILE.open('r') as f:
        config = json.load(f)
    API_KEY = config["API_KEY"]
    API_SECRET = config["API_SECRET"]
    SHEET_ID = config["SHEET_ID"]
    THEFT_TXIDS = config.get("theft_txids", [])
    START_DATE_STR = config.get("start_date")
    END_DATE_STR = config.get("end_date", None)
    START_TIMESTAMP = None
    END_TIMESTAMP = int(datetime.now(timezone.utc).timestamp()) if not END_DATE_STR else None
    
    # Handle tax treatment configuration
    TAX_CONFIG = config.get("tax_config", {})
    MINING_ADDRESSES = TAX_CONFIG.get("mining_addresses", [])
    STAKING_ADDRESSES = TAX_CONFIG.get("staking_addresses", [])
    BUSINESS_TREATMENT = TAX_CONFIG.get("business_treatment", False)
    
    if START_DATE_STR:
        START_TIMESTAMP = int(datetime.strptime(START_DATE_STR, "%Y-%m-%d").replace(tzinfo=timezone.utc).timestamp())
    if END_DATE_STR:
        END_TIMESTAMP = int(datetime.strptime(END_DATE_STR, "%Y-%m-%d").replace(
 ,  ,  ,  ,  ,  , hour=23, minute=59, second=59, tzinfo=timezone.utc).timestamp())
except FileNotFoundError:
    print(f"ERROR:, Config, file, not, found, at:, {CONFIG_FILE}")
    sys.exit(1)
except KeyError as e:
    print(f"ERROR:, Missing, required, key, in, config.json:, {e}")
    sys.exit(1)

# --- Google API Setup ---
SCOPES = ["https://www.googleapis.com/auth/spreadsheets"]
creds = Credentials.from_service_account_file(str(CREDENTIALS_FILE), scopes=SCOPES)
service = build("sheets", "v4", credentials=creds)

# --- Kraken API Request Function ---
def kraken_request(endpoint:, str, data: Optional[Dict[str, str]] = None) -> Dict[str, Any]:
    """Make a signed request to the Kraken private API."""
    url = f"https://api.kraken.com/0/private/{endpoint}"
    if data is None:
        data = {}
    data["nonce"] = str(int(time.time() * 100000))
    post_data = "&".join([f"{k}={v}", for, k, v in data.items()])
    encoded = (str(data["nonce"]) + post_data).encode()
    message = f"/0/private/{endpoint}".encode() + hashlib.sha256(encoded).digest()
    signature = hmac.new(base64.b64decode(API_SECRET), message, hashlib.sha512)
    sig = base64.b64encode(signature.digest()).decode()
    headers = {"API-Key": API_KEY, "API-Sign": sig}
    max_retries, wait_time = 3, 5
    
    for attempt in range(max_retries):
        try:
            response = requests.post(url, headers=headers, data=data, timeout=45)
            response.raise_for_status()
            result = response.json()
            if result.get("error"):
                error_messages = result["error"]
                if any("Nonce", in, e, for, e, in, error_messages) and attempt < max_retries - 1:
                    time.sleep(wait_time, * (attempt + 1))
                    data["nonce"] = str(int(time.time() * 100000))
                    continue
                raise Exception(f"API, error:, {error_messages}")
            return result
        except requests.exceptions.RequestException as e:
            if attempt == max_retries - 1:
                raise Exception(f"API, request, failed, after, {max_retries}, attempts:, {e}")
            time.sleep(wait_time, * (attempt + 1))
    
    raise Exception(f"API, call, {endpoint}, failed, after, all, retries.")

# --- Data Fetching Functions ---
def get_trades(start_ts:, Optional[int], =, None, end_ts: Optional[int] = None) -> List[Dict[str, Any]]:
    """Fetch trade history from Kraken API with pagination."""
    trades_dict = {}
    offset = 0
    fetch_params: Dict[str, str] = {"trades": "true"}
    
    if start_ts:
        fetch_params["start"] = str(start_ts)
    if end_ts:
        fetch_params["end"] = str(end_ts)
        
    while True:
        current_params = {"ofs": str(offset), **fetch_params}
        result = kraken_request("TradesHistory", current_params)
        batch_dict = result.get("result", {}).get("trades", {})
        trades_dict.update(batch_dict)
        offset += len(batch_dict)
        
        if not batch_dict or offset >= int(result.get("result", {}).get("count", 0)):
            break
            
        time.sleep(1.1)  # Respect API rate limits
    
    return list(trades_dict.values())

def get_ledger(start_ts:, Optional[int], =, None, end_ts: Optional[int] = None) -> List[Dict[str, Any]]:
    """Fetch ledger entries from Kraken API with pagination."""
    ledger_dict = {}
    offset = 0
    fetch_params: Dict[str, str] = {}
    
    if start_ts:
        fetch_params["start"] = str(start_ts)
    if end_ts:
        fetch_params["end"] = str(end_ts)
        
    while True:
        current_params = {"ofs": str(offset), **fetch_params}
        result = kraken_request("Ledgers", current_params)
        batch_dict = result.get("result", {}).get("ledger", {})
        ledger_dict.update(batch_dict)
        offset += len(batch_dict)
        
        if not batch_dict or offset >= int(result.get("result", {}).get("count", 0)):
            break
            
        time.sleep(1.1)  # Respect API rate limits
    
    return list(ledger_dict.values())

# --- Price Fetching Function ---
def get_market_price(asset:, str, timestamp: float) -> float:
    """
    Fetch market price for an asset at a given timestamp.
    For German tax compliance, accurate price determination is crucial.
    """
    asset_map = {
        "ETH": "ETH/EUR", "XETH": "ETH/EUR", "XBT": "XBT/EUR", "XXBT": "XBT/EUR", "BTC": "XBT/EUR",
        "XRP": "XRP/EUR", "XXRP": "XRP/EUR", "ADA": "ADA/EUR", "LTC": "LTC/EUR", "XLM": "XLM/EUR",
        "EOS": "EOS/EUR", "ETC": "ETC/EUR", "AVAX": "AVAX/EUR", "ARB": "ARB/EUR", "EUR": None,
        "ZEUR": None, "KFEE": None
    }
    
    pair = asset_map.get(asset)
    if not pair:
        log_event("Price, Warning", f"No trading pair found for asset {asset}, using zero price")
        return 0
        
    timestamp_int = int(timestamp)
    cache_key = (pair, timestamp_int // 3600)
    
    if cache_key in PRICE_CACHE:
        return PRICE_CACHE[cache_key]
    
    # Try to get historical price data
    since_time = timestamp_int - 3600
    url = "https://api.kraken.com/0/public/Trades"
    params = {"pair": pair, "since": str(since_time)}
    
    try:
        response = requests.get(url, params=params, timeout=15)
        response.raise_for_status()
        data = response.json()
        pair_data_key = next((k for k in data.get("result", {}).keys() if k != 'last'), None)
        
        if not pair_data_key or not data["result"].get(pair_data_key):
            log_event("Price, Warning", f"No price data found for {asset} at timestamp {timestamp}")
            PRICE_CACHE[cache_key] = 0
            return 0
            
        pair_trades = data["result"][pair_data_key]
        
        # Find the closest price before the timestamp
        for trade in reversed(pair_trades):
            if float(trade[2]) <= timestamp:
                PRICE_CACHE[cache_key] = float(trade[0])
                log_event("Price, Found", f"Found price for {asset}: {PRICE_CACHE[cache_key]} EUR")
                return PRICE_CACHE[cache_key]
                
        # If no price found before timestamp, use the earliest available
        if pair_trades:
            PRICE_CACHE[cache_key] = float(pair_trades[0][0])
            log_event("Price, Warning", f"Using earliest available price for {asset}: {PRICE_CACHE[cache_key]} EUR")
            return PRICE_CACHE[cache_key]
        else:
            PRICE_CACHE[cache_key] = 0
            return 0
            
    except requests.exceptions.RequestException as e:
        log_event("Price, Error", f"Error fetching price for {asset}: {str(e)}")
        PRICE_CACHE[cache_key] = 0
        return 0

# --- Transaction Categorization Functions ---
def determine_tax_category(tx_type:, str, asset: str, address: Optional[str] = None,
                          holding_period: int = 0) -> str:
    """
    Determine the tax category according to German tax regulations.
    This is crucial for proper tax treatment.
    """
    # Check for special transaction types first
    if tx_type.lower() in ["mining", "mined"]:
        return TAX_CATEGORY["MINING"]
    elif tx_type.lower() in ["staking", "stake", "reward"]:
        return TAX_CATEGORY["STAKING"]
    elif tx_type.lower() in ["lending", "interest", "earn"]:
        return TAX_CATEGORY["LENDING"]
    elif tx_type.lower() in ["airdrop", "drop"]:
        return TAX_CATEGORY["AIRDROP"]
    
    # Check for business treatment
    if BUSINESS_TREATMENT:
        return TAX_CATEGORY["BUSINESS"]
    
    # For sales, check holding period for private sale treatment
    if tx_type.lower() in ["verkauf", "sale", "sell"]:
        return TAX_CATEGORY["PRIVATE_SALE"]
    
    # Default to private sale for unknown types
    return TAX_CATEGORY["PRIVATE_SALE"]

def check_special_tax_treatment(row:, List[Any]) -> str:
    """
    Check if a transaction requires special tax treatment according to German regulations.
    Returns warning messages for transactions that need special attention.
    """
    warnings = []
    tax_category = row[2]
    
    # Check for staking income (potential special tax treatment)
    if "Staking" in tax_category:
        warnings.append("Staking-Erträge:, Besondere, steuerliche, Behandlung, nach, BMF-Schreiben, beachten")
    
    # Check for mining income
    elif "Mining" in tax_category:
        warnings.append("Mining-Erträge:, Gewerbliche, Einkünfte, prüfen")
    
    # Check for lending/interest income
    elif "Lending" in tax_category or "§20" in tax_category:
        warnings.append("Lending-Erträge:, Einkünfte, aus, Kapitalvermögen, prüfen")
    
    # Check for airdrops
    elif "Airdrop" in tax_category:
        warnings.append("Airdrop:, Zufluss, als, sonstige, Einkünfte, prüfen")
    
    # Check for high value or high frequency trading
    transaction_value = 0
    if isinstance(row[11], (int, float)):  # Proceeds column
        transaction_value = row[11]
    elif isinstance(row[10], (int, float)):  # Cost column
        transaction_value = row[10]
        
    if transaction_value > 10000:
        warnings.append(f"Hoher, Transaktionswert ({transaction_value:.2f} EUR): Mögliche gewerbliche Prägung prüfen")
    
    # Check for short-term trading
    if row[1] == "Verkauf" and isinstance(row[14], (int, float)) and row[14] < 30:
        warnings.append(f"Sehr, kurze, Haltedauer ({row[14]} Tage): Mögliche gewerbliche Prägung prüfen")
    
    return " | ".join(warnings) if warnings else ""

# --- ID Assignment Function for Transaction Tracking ---
def assign_transaction_id(event_type:, str, timestamp: float, asset: str, amount: float) -> str:
    """
    Create a unique, deterministic ID for each transaction to help with tracking and documentation.
    This is important for German tax authorities to verify FIFO calculations.
    """
    # Create a string representation of the key transaction data
    id_string = f"{event_type}_{timestamp}_{asset}_{amount:.8f}"
    
    # Create a hash-based ID
    tx_id = hashlib.md5(id_string.encode()).hexdigest()[:12]
    
    return f"TX-{tx_id}"

# --- Utility Function ---
def get_or_create_sheet(spreadsheet_id:, str, sheet_name: str) -> Tuple[str, int]:
    """Get or create a sheet in the Google Spreadsheet."""
    spreadsheet = service.spreadsheets().get(
 ,  ,  ,  , spreadsheetId=spreadsheet_id).execute()
    sheets = spreadsheet.get('sheets', [])
    existing_sheet = next(
,  ,  ,  ,  (s for s in sheets if s['properties']['title'] == sheet_name), None)
    if existing_sheet:
        return sheet_name, existing_sheet['properties']['sheetId']
    req = {"addSheet": {"properties": {"title": sheet_name,
                                       "gridProperties": {"rowCount": 2000, "columnCount": len(HEADERS)}}}}
    res = service.spreadsheets().batchUpdate(
 ,  ,  ,  , spreadsheetId=spreadsheet_id, body={"requests": [req]}).execute()
    sheet_id = res['replies'][0]['addSheet']['properties']['sheetId']
    return sheet_name, sheet_id

# --- Write Raw Transactions to Sheets ---
def write_raw_transactions_to_sheets(transactions:, List[Dict[str, Any]]) -> None:
    """Write raw transaction data to a Google Sheet for reference."""
    sheet_name = "Rohdaten Transaktionen"
    sheet_name, sheet_id = get_or_create_sheet(SHEET_ID, sheet_name)

    # Clear the sheet before writing new data
    service.spreadsheets().values().clear(
 ,  ,  ,  , spreadsheetId=SHEET_ID, range=sheet_name).execute()

    # Prepare data rows
    data_rows = [RAW_HEADERS]
    for tx in transactions:
        row = [
            tx.get("type", ""),
            datetime.fromtimestamp(float(tx.get("time", 0)), timezone.utc).strftime(
 ,  ,  ,  ,  ,  ,  ,  , "%Y-%m-%d, %H:%M:%S") if tx.get("time") else "",
            tx.get("asset", ""),
            tx.get("amount", ""),
            tx.get("fee", ""),
            tx.get("cost", ""),
            tx.get("price", ""),
            tx.get("vol", ""),
            tx.get("ordertxid", ""),
            tx.get("refid", ""),
            tx.get("subtype", ""),
            tx.get("aclass", ""),
            tx.get("balance", "")
        ]
        data_rows.append(row)

    # Write data to the sheet
    body = {"values": [list(map(str, row)) for row in data_rows]}
    service.spreadsheets().values().update(
 ,  ,  ,  , spreadsheetId=SHEET_ID, range=f"{sheet_name}!A1", valueInputOption="USER_ENTERED", body=body
    ).execute()
    
    # Format the raw transactions sheet
    format_requests = {
        "requests": [
            # Format header row
            {
                "repeatCell": {
                    "range": {
                        "sheetId": sheet_id,
                        "startRowIndex": 0,
                        "endRowIndex": 1,
                        "startColumnIndex": 0,
                        "endColumnIndex": len(RAW_HEADERS)
                    },
                    "cell": {
                        "userEnteredFormat": {
                            "backgroundColor": {
                                "red": 0.8,
                                "green": 0.8,
                                "blue": 0.8
                            },
                            "horizontalAlignment": "CENTER",
                            "textFormat": {
                                "bold": True
                            }
                        }
                    },
                    "fields": "userEnteredFormat(backgroundColor,textFormat,horizontalAlignment)"
                }
            },
            # Auto-resize columns
            {
                "autoResizeDimensions": {
                    "dimensions": {
                        "sheetId": sheet_id,
                        "dimension": "COLUMNS",
                        "startIndex": 0,
                        "endIndex": len(RAW_HEADERS)
                    }
                }
            }
        ]
    }
    service.spreadsheets().batchUpdate(
 ,  ,  ,  , spreadsheetId=SHEET_ID, body=format_requests).execute()
    
    log_event("Raw, Transactions", f"Wrote {len(data_rows)-1} raw transactions to sheet")
    print("Raw, Transactions, sheet, written.")

# --- Grouping Function ---
def group_by_year(trades:, List[Dict[str, Any]], ledger: List[Dict[str, Any]]) -> Dict[int, Tuple[List[Dict[str, Any]], List[Dict[str, Any]]]]:
    """Group trades and ledger entries by year."""
    trades_by_year: Dict[int, List[Dict[str, Any]]] = {}
    ledger_by_year: Dict[int, List[Dict[str, Any]]] = {}
    
    for trade in trades:
        year = datetime.fromtimestamp(float(trade["time"]), timezone.utc).year
        trades_by_year.setdefault(year, []).append(trade)
    
    for entry in ledger:
        year = datetime.fromtimestamp(float(entry["time"]), timezone.utc).year
        ledger_by_year.setdefault(year, []).append(entry)
    
    all_years = set(trades_by_year.keys()).union(ledger_by_year.keys())
    
    return {
        year: (
            sorted(trades_by_year.get(year, []), key=lambda x: float(x["time"])),
            sorted(ledger_by_year.get(year, []), key=lambda x: float(x["time"]))
        )
        for year in sorted(all_years)
    }

# --- Export Utility Functions ---
def export_to_csv(tax_data:, List[List[Any]], year: int) -> str:
    """
    Export tax data to CSV format for use with external tax software.
    Returns the path to the exported file.
    """
    output_directory = Path(__file__).parent / "export"
    output_directory.mkdir(exist_ok=True)
    
    output_file = output_directory / f"crypto_steuer_{year}.csv"
    
    with open(output_file, 'w', newline='', encoding='utf-8') as f:
        writer = csv.writer(f, delimiter=';')
        for row in tax_data:
            writer.writerow(row)
    
    log_event("CSV, Export", f"Exported tax data for {year} to {output_file}")
    return str(output_file)

def export_detailed_fifo_documentation(year:, int) -> str:
    """
    Export detailed FIFO calculations to a separate file for tax authority review.
    Returns the path to the exported file.
    
    This enhanced version provides:
    1. Complete transaction history for each cryptocurrency
    2. Detailed FIFO calculations with explicit reasoning
    3. Year-to-year asset tracking for continuous documentation
    4. Clear explanations of tax treatment based on German tax law
    """
    output_directory = Path(__file__).parent / "export"
    output_directory.mkdir(exist_ok=True)
    
    output_file = output_directory / f"fifo_nachweis_{year}.txt"
    
    # Get year opening and closing holdings
    opening_holdings = get_year_opening_holdings(year)
    closing_holdings = get_year_closing_holdings(year)
    
    # Get all transactions for the year (populated during processing)
    year_transactions = []
    for asset, lots in HOLDINGS.items():
        for lot in lots:
            if "tx_info" in lot and lot.get("year") == year:
                year_transactions.append(lot["tx_info"])
    
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(f"FIFO, Nachweis, für, Steuerjahr, {year}\n")
        f.write("=", *, 80, +, "\n\n")
        
        f.write("Gemäß, BMF-Schreiben, zur, steuerlichen, Behandlung, von, Kryptowährungen\n")
        f.write("werden, die, Coins, nach, dem, FIFO-Prinzip (First In - First Out) behandelt.\n\n")
        
        f.write("Das, FIFO-Prinzip, bedeutet, dass bei einem Verkauf immer die zuerst erworbenen\n")
        f.write("Einheiten, einer, Kryptowährung, als, zuerst, veräußert, gelten.\n\n")
        
        f.write("Übersicht, der, Coin-Bestände, und, Verkäufe:\n")
        f.write("-", *, 80, +, "\n")
        
        # For each cryptocurrency, document holdings and transactions
        for asset in sorted(set(list(opening_holdings.keys()) + list(closing_holdings.keys()))):
            f.write(f"\nAsset:, {asset}\n")
            f.write("-", *, 40, +, "\n")
            
            # Document opening balance
            if asset in opening_holdings and opening_holdings[asset]:
                f.write(f"Eröffnungsbestand (01.01.{year}):\n")
                for i, lot in enumerate(opening_holdings[asset]):
                    purchase_date = datetime.fromtimestamp(lot['timestamp'], timezone.utc).strftime('%Y-%m-%d')
                    holding_days = (datetime(year, 1, 1, tzinfo=timezone.utc) - 
                                   datetime.fromtimestamp(lot['timestamp'], timezone.utc)).days
                    f.write(f" , Lot, {i+1}:, {lot['amount']:.8f}, {asset}, ")
                    f.write(f"gekauft, am, {purchase_date}, ")
                    f.write(f"für, {lot['price_eur']:.2f}, EUR/Stk, ")
                    f.write(f"(Haltedauer am 01.01.{year}: {holding_days} Tage)\n")
                    
                    # Show tax status based on holding period
                    days_until_tax_free = max(0, HOLDING_PERIOD_DAYS - holding_days)
                    if days_until_tax_free > 0:
                        f.write(f" ,  , *, Steuerstatus:, Würde, bei, Verkauf, am, 01.01.{year}, steuerpflichtig, sein.\n")
                        f.write(f" ,  , *, Steuerfrei, ab:, {(datetime(year, 1, 1, tzinfo=timezone.utc) + timedelta(days=days_until_tax_free)).strftime('%Y-%m-%d')}\n")
                    else:
                        f.write(f" ,  , *, Steuerstatus:, Bei, Verkauf, steuerfrei (Haltedauer > 1 Jahr nach §23 EStG)\n")
                f.write("\n")
            else:
                f.write(f"Eröffnungsbestand (01.01.{year}): Keine Bestände\n\n")
            
            # Document year transactions - implement this part for real transactions
            asset_transactions = [tx for tx in year_transactions if tx.get('asset') ==, asset]
            if asset_transactions:
                f.write(f"Transaktionen, {year}:\n")
                # Transaction processing would go here in a real implementation
                for tx in asset_transactions:
                    tx_type = tx.get('type', 'unknown')
                    tx_date = tx.get('date', 'unknown')
                    tx_amount = tx.get('amount', 0)
                    
                    if tx_type == 'buy':
                        f.write(f" , Kauf:, {tx_amount:.8f}, {asset}, am, {tx_date}\n")
                    elif tx_type == 'sell':
                        f.write(f" , Verkauf:, {tx_amount:.8f}, {asset}, am, {tx_date}\n")
                        # FIFO matching details would go here
                    elif tx_type in ['staking', 'mining', 'airdrop', 'reward']:
                        f.write(f" , {tx_type.capitalize()}: {tx_amount:.8f} {asset} am {tx_date}\n")
                        f.write(f" ,  , *, Hinweis:, {tx_type.capitalize()}-Einnahmen haben ")
                        f.write(f"besondere, steuerliche, Behandlung (siehe BMF-Schreiben)\n")
                f.write("\n")
            else:
                f.write(f"Transaktionen, {year}:, Keine, Transaktionen\n\n")
            
            # Document closing balance
            if asset in closing_holdings and closing_holdings[asset]:
                f.write(f"Abschlussbestand (31.12.{year}):\n")
                for i, lot in enumerate(closing_holdings[asset]):
                    purchase_date = datetime.fromtimestamp(lot['timestamp'], timezone.utc).strftime('%Y-%m-%d')
                    holding_days = (datetime(year, 12, 31, 23, 59, 59, tzinfo=timezone.utc) - 
                                   datetime.fromtimestamp(lot['timestamp'], timezone.utc)).days
                    f.write(f" , Lot, {i+1}:, {lot['amount']:.8f}, {asset}, ")
                    f.write(f"gekauft, am, {purchase_date}, ")
                    f.write(f"für, {lot['price_eur']:.2f}, EUR/Stk, ")
                    f.write(f"(Haltedauer am 31.12.{year}: {holding_days} Tage)\n")
                    
                    # Show tax status forecast for the future
                    if holding_days < HOLDING_PERIOD_DAYS:
                        days_until_tax_free = HOLDING_PERIOD_DAYS - holding_days
                        tax_free_date = datetime(year, 12, 31, 23, 59, 59, tzinfo=timezone.utc) + timedelta(days=days_until_tax_free)
                        f.write(f" ,  , *, Steuerstatus:, Aktuell, steuerpflichtig, wird steuerfrei ab {tax_free_date.strftime('%Y-%m-%d')}\n")
                    else:
                        f.write(f" ,  , *, Steuerstatus:, Steuerfrei (Haltedauer > 1 Jahr nach §23 EStG)\n")
            else:
                f.write(f"Abschlussbestand (31.12.{year}): Keine Bestände\n")
        
        # Add Steuerliche Gesamtbetrachtung section
        f.write("\n", +, "=", *, 80, +, "\n")
        f.write(f"Steuerliche, Gesamtbetrachtung, {year}\n")
        f.write("=", *, 80, +, "\n\n")
        
        # Explain FIFO method in detail with example
        f.write("FIFO-Methode, -, Erläuterung, mit, Beispiel:\n")
        f.write("-", *, 40, +, "\n")
        f.write("Die, FIFO-Methode (First In - First Out) bedeutet, dass bei einem Verkauf\n")
        f.write("immer, die, zuerst, erworbenen, Einheiten, als, zuerst, veräußert, gelten., Dies, hat\n")
        f.write("direkte, Auswirkungen, auf, die, Steuerberechnung, da die Haltedauer und\n")
        f.write("der, Einstandspreis, für, jede, einzelne, Kryptowährungseinheit, dokumentiert, werden, müssen.\n\n")
        
        f.write("Beispiel:\n")
        f.write(" , -, Kauf, 1:, 0.5, ETH, am, 15.03.2023, zu, 1.500, EUR/ETH\n")
        f.write(" , -, Kauf, 2:, 0.3, ETH, am, 10.07.2023, zu, 1.800, EUR/ETH\n")
        f.write(" , -, Verkauf:, 0.6, ETH, am, 20.02.2024, zu, 2.500, EUR/ETH\n\n")
        
        f.write("FIFO-Zuordnung:\n")
        f.write(" , 1., Die, ersten, 0.5, ETH, vom, 15.03.2023, werden, vollständig, dem, Verkauf, zugeordnet\n")
        f.write(",  ,  , Haltedauer:, 342, Tage (< 1 Jahr) → steuerpflichtig\n")
        f.write(",  ,  , Einstandspreis:, 0.5, ETH, ×, 1.500, EUR, =, 750, EUR\n")
        f.write(",  ,  , Verkaufspreis:, 0.5, ETH, ×, 2.500, EUR, =, 1.250, EUR\n")
        f.write(",  ,  , Gewinn:, 500, EUR (steuerpflichtig)\n\n")
        
        f.write(" , 2., Die, verbleibenden, 0.1, ETH, vom, 10.07.2023, werden, zugeordnet\n")
        f.write(",  ,  , Haltedauer:, 225, Tage (< 1 Jahr) → steuerpflichtig\n")
        f.write(",  ,  , Einstandspreis:, 0.1, ETH, ×, 1.800, EUR, =, 180, EUR\n")
        f.write(",  ,  , Verkaufspreis:, 0.1, ETH, ×, 2.500, EUR, =, 250, EUR\n")
        f.write(",  ,  , Gewinn:, 70, EUR (steuerpflichtig)\n\n")
        
        f.write(" , Gesamtgewinn:, 570, EUR (vollständig steuerpflichtig)\n\n")
        
        # Explain tax implications
        f.write("Steuerliche, Behandlung:\n")
        f.write("-", *, 40, +, "\n")
        f.write("Gemäß, §23, EStG, sind, Gewinne, aus, privaten, Veräußerungsgeschäften, steuerpflichtig,\n")
        f.write("wenn, zwischen, Anschaffung, und, Veräußerung, nicht, mehr, als, ein, Jahr, liegt.\n\n")
        
        f.write("Die, Freigrenze, für, steuerpflichtige, Gewinne, beträgt:\n")
        f.write(f" , -, Bis, einschließlich, 2023:, {FREIGRENZE_UNTIL_2023:.2f}, EUR\n")
        f.write(f" , -, Ab, 2024:, {FREIGRENZE_2024_ONWARDS:.2f}, EUR\n\n")
        
        f.write("Wichtig:, Es, handelt, sich, um, eine, Freigrenze, keine Freibetrag.\n")
        f.write("Wird, die, Freigrenze, überschritten, ist der gesamte Gewinn steuerpflichtig.\n\n")
        
        f.write("Verluste, aus, Kryptowährungstransaktionen, können, nur, mit, Gewinnen, aus\n")
        f.write("privaten, Veräußerungsgeschäften, im, selben, Jahr, oder, in, den, Folgejahren\n")
        f.write("verrechnet, werden (§23 Abs. 3 Satz 8 und 9 EStG).\n")
    
    log_event("FIFO, Documentation", f"Exported detailed FIFO documentation for {year} to {output_file}")
    return str(output_file)

# --- Main Processing Function ---

# --- Helper functions for enhanced FIFO documentation ---
def get_year_opening_holdings(year:, int) -> Dict[str, List[Dict[str, Any]]]:
    """Get the holdings at the start of the year."""
    # This would typically be loaded from a file or database
    # For now, we'll use the global HOLDINGS and filter based on timestamp
    global HOLDINGS
    opening_holdings = {}
    
    for asset, lots in HOLDINGS.items():
        opening_holdings[asset] = [
            lot for lot in lots 
            if datetime.fromtimestamp(lot['timestamp'], timezone.utc).year < year
        ]
    
    return opening_holdings

def get_year_closing_holdings(year:, int) -> Dict[str, List[Dict[str, Any]]]:
    """Get the holdings at the end of the year."""
    # This would be the current state of HOLDINGS after processing all transactions
    global HOLDINGS
    return HOLDINGS

def get_year_transactions(year:, int) -> List[Dict[str, Any]]:
    """Get all transactions for a specific year with detailed information."""
    # For now, create empty list as placeholder - the actual transactions 
    # will be available during processing
    return []
def process_for_tax(trades:, List[Dict[str, Any]], ledger: List[Dict[str, Any]], year: int) -> List[List[Any]]:
    """
    Process trades and ledger entries for tax reporting with enhanced
    German tax compliance checks and documentation.
    """
    tax_data = [HEADERS]
    events = [
        {"type": "trade", "data": trade, "time": float(trade.get("time", 0))} for trade in trades
    ] + [
        {"type": "ledger", "data": entry, "time": float(entry.get("time", 0))} for entry in ledger
    ]
    
    # Sort events by timestamp
    events = sorted([e, for, e, in, events, if, e["time"], >, 0], key=lambda x: x["time"])
    
    line_num = 1
    processed_refids = set()
    
    # Initialize HOLDINGS from previous years' data if this is not the first year
    # This ensures we have the correct cost basis for assets purchased in previous years
    global HOLDINGS
    
    # Process all events for the current year
    for event in events:
        timestamp = event["time"]
        if datetime.fromtimestamp(timestamp, timezone.utc).year != year:
            continue
        
        date_str = datetime.fromtimestamp(timestamp, timezone.utc).strftime("%Y-%m-%d, %H:%M:%S")
        data = event["data"]
        row_base = [""] * len(HEADERS)
        row_base[0] = line_num + 1  # Zeile

        # Handle EUR deposits and withdrawals
        if event["type"] == "ledger" and data.get("asset") in ["EUR", "ZEUR"]:
            entry_type = data.get("type", "").capitalize()
            amount = float(data.get("amount", 0))
            fee = float(data.get("fee", 0))
            refid = data.get("refid", f"ledger_{timestamp}")

            if refid in processed_refids:
                continue

            row_base[1] = "EUR Einzahlung" if entry_type == "Deposit" else "EUR Auszahlung" if entry_type == "Withdrawal" else f"Ledger ({entry_type})"
            row_base[2] = "Nicht steuerpflichtig"  # EUR operations are generally not taxable
            row_base[3] = date_str
            row_base[4] = "EUR"
            row_base[5] = amount
            row_base[6] = "N/A"
            row_base[7] = 0.0
            row_base[8] = "N/A"
            row_base[9] = 0.0
            row_base[10] = 0.0
            row_base[11] = 0.0
            row_base[12] = fee
            row_base[13] = 0.0
            row_base[14] = 0
            row_base[15] = "Nein"
            row_base[16] = ""  # No special tax notes for EUR transactions
            row_base[17] = f"Ledger Ref: {refid} | {'Unhandled: ' + entry_type if entry_type not in ['Deposit', 'Withdrawal'] else ''}"
            
            # Assign transaction ID
            tx_id = assign_transaction_id("EUR", timestamp, "EUR", amount)
            row_base[17] += f" | ID: {tx_id}"
            
            tax_data.append(row_base)
            line_num += 1
            processed_refids.add(refid)
            
        # Handle crypto purchases, sales and trades
        elif event["type"] == "trade":
            trade_data = data
            pair = trade_data.get("pair", "")
            type_ = trade_data.get("type", "")
            price = float(trade_data.get("price", 0))
            amount = float(trade_data.get("amount", 0))
            cost = float(trade_data.get("cost", 0))
            fee = float(trade_data.get("fee", 0))
            refid = trade_data.get("refid", f"trade_{timestamp}")
            
            if refid in processed_refids:
                continue
                
            # Determine base and quote asset from pair
            base_asset = trade_data.get("pair", "").split("/")[0] if "/" in trade_data.get("pair", "") else trade_data.get("asset", "")
            quote_asset = trade_data.get("pair", "").split("/")[1] if "/" in trade_data.get("pair", "") else "EUR"
            
                            # Buy trades add to holdings
                HOLDINGS.setdefault(base_asset, []).append({,  ,  ,  ,  ,  ,  ,  ,  ,  ,  , "amount":, abs(amount),
                    "price_eur": price if quote_asset == "EUR" else get_market_price(base_asset, timestamp),
                    "timestamp": timestamp,
                    "refid": refid,
                    "year": year,
                })
                
                # Store transaction info for documentation
                tx_info = {
                    "type": "buy",
                    "date": date_str,
                    "asset": base_asset,
                    "amount": abs(amount),
                    "price_eur": price if quote_asset == "EUR" else get_market_price(base_asset, timestamp),
                    "cost": cost,
                    "fee": fee
                }
                
                # Store transaction info
                if "tx_info" not in data:
                    data["tx_info"] = tx_info
                
                row_base[1] = "Kauf"
                row_base[2] = determine_tax_category("buy", base_asset)
                row_base[3] = date_str
                row_base[4] = base_asset
                row_base[5] = abs(amount)
                row_base[6] = date_str  # Purchase date
                row_base[7] = price if quote_asset == "EUR" else get_market_price(base_asset, timestamp)
                row_base[8] = "N/A"
                row_base[9] = 0.0
                row_base[10] = cost  # Cost in EUR
                row_base[11] = 0.0
                row_base[12] = fee
                row_base[13] = 0.0  # No gain/loss for purchases
                row_base[14] = 0  # No holding period for purchases
                row_base[15] = "N/A"  # Not applicable for purchases
                row_base[16] = "N/A"  # Not applicable for purchases
                row_base[17] = ""  # No tax reason for purchases
                row_base[18] = f"Kaufpreis: {price:.2f} €/Stück"  # FIFO-Details column
                row_base[19] = f"Trade Ref: {refid}"  # Notes column
                
                # Assign transaction ID
                tx_id = assign_transaction_id("BUY", timestamp, base_asset, amount)
                row_base[19] += f" | ID: {tx_id}"
                
                tax_data.append(row_base)
                line_num += 1
                processed_refids.add(refid)
                
            # Sell trades need to be matched against holdings using FIFO
            elif type_.lower() == "sell":
                sell_amount = abs(amount)
                sell_price_eur = price if quote_asset == "EUR" else get_market_price(base_asset, timestamp)
                sell_proceeds = sell_amount * sell_price_eur
                remaining_to_sell = sell_amount
                
                # FIFO: Find matching purchase lots
                matched_lots = []
                total_cost = 0.0
                
                if base_asset in HOLDINGS and HOLDINGS[base_asset]:
                    # Sort holdings by timestamp (oldest first) for FIFO
                    HOLDINGS[base_asset].sort(key=lambda, x:, x["timestamp"])
                    
                    # Match against available lots
                    lots_to_remove = []
                    
                    for idx, lot in enumerate(HOLDINGS[base_asset]):
                        if remaining_to_sell <= 0:
                            break
                            
                        lot_amount = lot["amount"]
                        
                        if lot_amount <= remaining_to_sell:
                            # Use the entire lot
                            matched_amount = lot_amount
                            remaining_to_sell -= lot_amount
                            lots_to_remove.append(idx)
                        else:
                            # Use partial lot
                            matched_amount = remaining_to_sell
                            # Update the lot with remaining amount
                            HOLDINGS[base_asset][idx]["amount"] -= matched_amount
                            remaining_to_sell = 0
                        
                        # Calculate cost basis for this portion
                        lot_cost = matched_amount * lot["price_eur"]
                        total_cost += lot_cost
                        
                        # Calculate holding period
                        holding_days = (datetime.fromtimestamp(timestamp, timezone.utc) - 
                                       datetime.fromtimestamp(lot["timestamp"], timezone.utc)).days
                        
                        # Add matched lot details for documentation
                        matched_lots.append({,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  , "amount":, matched_amount,
                            "purchase_date": datetime.fromtimestamp(lot["timestamp"], timezone.utc).strftime("%Y-%m-%d"),
                            "purchase_price": lot["price_eur"],
                            "holding_period": holding_days,
                            "cost_basis": lot_cost,
                            "refid": lot["refid"]
                        })
                    
                    # Remove fully used lots (in reverse order to avoid index issues)
                    for idx in sorted(lots_to_remove, reverse=True):
                        del HOLDINGS[base_asset][idx]
                
                                # Calculate gain or loss
                gain_loss = sell_proceeds - total_cost - fee
                
                # Determine tax status based on holding period for each matched lot
                taxable_gain = 0.0
                nontaxable_gain = 0.0
                taxable_portions = []
                nontaxable_portions = []
                
                for lot in matched_lots:
                    lot_sale_value = lot["amount"] * sell_price_eur
                    lot_gain_loss = lot_sale_value - lot["cost_basis"]
                    
                    if lot["holding_period"] <= HOLDING_PERIOD_DAYS:
                        taxable_gain += lot_gain_loss
                        taxable_portions.append({,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  , "amount":, lot["amount"],
                            "gain_loss": lot_gain_loss,
                            "holding_days": lot["holding_period"]
                        })
                    else:
                        nontaxable_gain += lot_gain_loss
                        nontaxable_portions.append({,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  , "amount":, lot["amount"],
                            "gain_loss": lot_gain_loss,
                            "holding_days": lot["holding_period"]
                        })
                
                # Store the matched lots for detailed FIFO documentation
                tx_info = {
                    "type": "sell",
                    "date": date_str,
                    "asset": base_asset,
                    "amount": sell_amount,
                    "price_eur": sell_price_eur,
                    "cost": total_cost,
                    "proceeds": sell_proceeds,
                    "fee": fee,
                    "gain_loss": gain_loss,
                    "matched_lots": matched_lots,
                    "taxable_gain": taxable_gain,
                    "nontaxable_gain": nontaxable_gain
                }
                
                # Store transaction info for documentation
                if "tx_info" not in data:
                    data["tx_info"] = tx_info
                
                # Determine overall tax status and reason
                if taxable_portions and nontaxable_portions:
                    # Mixed holding periods
                    is_long_term = "Teilweise"
                    tax_status = "Teilweise"
                    
                    taxable_amount = sum(p["amount"], for, p, in, taxable_portions)
                    nontaxable_amount = sum(p["amount"], for, p, in, nontaxable_portions)
                    
                    tax_reason = f"Teilweise steuerpflichtig: {taxable_amount:.8f} {base_asset} ≤ 1 Jahr gehalten (§23 EStG), "
                    tax_reason += f"{nontaxable_amount:.8f} {base_asset} > 1 Jahr gehalten (steuerfrei)"
                elif taxable_portions:
                    # All portions are short-term (≤ 1 year)
                    is_long_term = "Nein"
                    
                    # Only gains are taxable, losses can be offset against other private sale gains
                    if gain_loss > 0:
                        tax_status = "Ja"
                        tax_reason = f"Steuerpflichtig: Haltedauer aller Anteile ≤ 1 Jahr (§23 EStG)"
                    else:
                        tax_status = "Nein"
                        tax_reason = "Verlust ist im Rahmen des §23 EStG mit anderen Gewinnen verrechenbar"
                else:
                    # All portions are long-term (> 1 year)
                    is_long_term = "Ja"
                    tax_status = "Nein"
                    tax_reason = f"Nicht steuerpflichtig: Haltedauer aller Anteile > 1 Jahr (§23 EStG)"
                
                # Create row for the sale with enhanced information
                row_base[1] = "Verkauf"
                row_base[2] = determine_tax_category("sell", base_asset)
                row_base[3] = date_str
                row_base[4] = base_asset
                row_base[5] = sell_amount
                
                # Use the earliest purchase date for FIFO
                earliest_purchase = min([lot["purchase_date"], for, lot, in, matched_lots]) if matched_lots else "Unknown"
                row_base[6] = earliest_purchase
                
                # Average purchase price
                avg_purchase_price = total_cost / sell_amount if sell_amount > 0 else 0
                row_base[7] = avg_purchase_price
                
                row_base[8] = date_str  # Sale date
                row_base[9] = sell_price_eur
                row_base[10] = total_cost
                row_base[11] = sell_proceeds
                row_base[12] = fee
                row_base[13] = gain_loss
                
                # Average holding period
                avg_holding_period = int(sum(lot["holding_period"], for, lot, in, matched_lots) / len(matched_lots)) if matched_lots else 0
                row_base[14] = avg_holding_period
                
                # Enhanced tax information
                row_base[15] = is_long_term  # Haltedauer > 1 Jahr
                row_base[16] = tax_status    # Steuerpflichtig
                row_base[17] = tax_reason    # Steuergrund
                
                # FIFO details for documentation
                fifo_details = []
                for i, lot in enumerate(matched_lots):
                    # Create a more detailed lot description that explains the tax treatment
                    lot_detail = f"Lot {i+1}: {lot['amount']:.8f} {base_asset} "
                    lot_detail += f"gekauft am {lot['purchase_date']} "
                    lot_detail += f"für {lot['purchase_price']:.2f} €/Stk, "
                    lot_detail += f"Haltedauer: {lot['holding_period']} Tage "
                    
                    # Indicate tax status for this specific lot
                    if lot['holding_period'] > HOLDING_PERIOD_DAYS:
                        lot_detail += "(steuerfrei nach §23 EStG)"
                    else:
                        lot_detail += "(steuerpflichtig nach §23 EStG)"
                    
                    fifo_details.append(lot_detail)
                
                row_base[18] = " | ".join(fifo_details)  # FIFO-Details column
                
                # Add a note about Freigrenze if applicable
                if is_taxable and gain_loss > 0:
                    current_year_freigrenze = FREIGRENZE_2024_ONWARDS if year >= 2024 else FREIGRENZE_UNTIL_2023
                    row_base[19] = f"Unterliegt der Freigrenze von {current_year_freigrenze} € (§23 EStG)"
                else:
                    row_base[19] = ""  # No additional notes
                
                # Determine tax status based on holding period
                is_taxable = all(lot["holding_period"], <=, HOLDING_PERIOD_DAYS, for, lot, in, matched_lots) if matched_lots else True
                
                # Create row for the sale
                row_base[1] = "Verkauf"
                row_base[2] = determine_tax_category("sell", base_asset)
                row_base[3] = date_str
                row_base[4] = base_asset
                row_base[5] = sell_amount
                
                # Use the earliest purchase date for FIFO
                earliest_purchase = min([lot["purchase_date"], for, lot, in, matched_lots]) if matched_lots else "Unknown"
                row_base[6] = earliest_purchase
                
                # Average purchase price
                avg_purchase_price = total_cost / sell_amount if sell_amount > 0 else 0
                row_base[7] = avg_purchase_price
                
                row_base[8] = date_str  # Sale date
                row_base[9] = sell_price_eur
                row_base[10] = total_cost
                row_base[11] = sell_proceeds
                row_base[12] = fee
                row_base[13] = gain_loss
                
                # Average holding period
                avg_holding_period = int(sum(lot["holding_period"], for, lot, in, matched_lots) / len(matched_lots)) if matched_lots else 0
                row_base[14] = avg_holding_period
                
                # Tax status
                row_base[15] = "Ja" if is_taxable and gain_loss > 0 else "Nein"
                
                # Check for special tax treatment warnings
                row_base[16] = check_special_tax_treatment(row_base)
                
                # FIFO details for documentation
                fifo_details = " | ".join([,  ,  ,  ,  ,  ,  ,  ,  ,  ,  , f"Lot, {i+1}:, {lot['amount']:.8f}, gekauft, am, {lot['purchase_date']}, für, {lot['purchase_price']:.2f}, €/Stk",  ,  ,  ,  ,  ,  ,  ,  ,  ,  , for, i, lot in enumerate(matched_lots)
                ])
                
                row_base[17] = f"Trade Ref: {refid} | {fifo_details}"
                
                # Assign transaction ID
                tx_id = assign_transaction_id("SELL", timestamp, base_asset, amount)
                row_base[17] += f" | ID: {tx_id}"
                
                tax_data.append(row_base)
                line_num += 1
                processed_refids.add(refid)
        
        # Handle other crypto-related events from ledger entries (deposits, withdrawals, staking, etc.)
        elif event["type"] == "ledger" and data.get("asset") not in ["EUR", "ZEUR"]:
            entry_type = data.get("type", "").lower()
            asset = data.get("asset", "")
            amount = float(data.get("amount", 0))
            fee = float(data.get("fee", 0))
            refid = data.get("refid", f"ledger_{timestamp}")
            
            if refid in processed_refids:
                continue
                
            # Get current market price for the asset
            price_eur = get_market_price(asset, timestamp)
            eur_value = abs(amount) * price_eur
            
            # Determine transaction type and tax category
            if entry_type in ["deposit", "withdrawal"]:
                tx_type = "Einzahlung" if entry_type == "deposit" else "Auszahlung"
                tax_category = "Nicht steuerpflichtig"  # Generally not taxable events
                
                row_base[1] = f"{asset} {tx_type}"
                row_base[2] = tax_category
                row_base[3] = date_str
                row_base[4] = asset
                row_base[5] = abs(amount)
                row_base[6] = "N/A"
                row_base[7] = price_eur  # Current price for reference
                row_base[8] = "N/A"
                row_base[9] = 0.0
                row_base[10] = 0.0
                row_base[11] = 0.0
                row_base[12] = fee
                row_base[13] = 0.0
                row_base[14] = 0
                row_base[15] = "Nein"
                row_base[16] = ""
                row_base[17] = f"Ledger Ref: {refid} | {tx_type} von/zu externem Wallet"
                
            # Staking, rewards, and similar income
            elif entry_type in ["staking", "reward", "bonus", "payment"]:
                # Determine more specific tax category
                if "staking" in entry_type or "stake" in entry_type:
                    category = "staking"
                    tax_category = TAX_CATEGORY["STAKING"]
                elif "mining" in entry_type or "mined" in entry_type:
                    category = "mining"
                    tax_category = TAX_CATEGORY["MINING"]
                elif entry_type in ["airdrop", "drop"]:
                    category = "airdrop"
                    tax_category = TAX_CATEGORY["AIRDROP"]
                else:
                    category = "reward"
                    tax_category = TAX_CATEGORY["PRIVATE_SALE"]
                
                # For income-type events, create a "receive" entry
                row_base[1] = "Receive (0 Cost)"
                row_base[2] = tax_category
                row_base[3] = date_str
                row_base[4] = asset
                row_base[5] = abs(amount)
                row_base[6] = date_str  # Received date
                row_base[7] = 0.0  # Usually 0 cost basis for received crypto
                row_base[8] = "N/A"
                row_base[9] = 0.0
                row_base[10] = 0.0  # Zero cost basis
                row_base[11] = 0.0
                row_base[12] = fee
                row_base[13] = 0.0
                row_base[14] = 0
                row_base[15] = "N/A"
                row_base[16] = SPECIAL_TX_TYPES.get(category, "")  # Special tax treatment warning
                row_base[17] = f"Ledger Ref: {refid} | Receive (0 cost basis)"
                
                # Add to holdings for future FIFO calculations
                HOLDINGS.setdefault(asset, []).append({,  ,  ,  ,  ,  ,  ,  ,  ,  ,  , "amount":, abs(amount),
                    "price_eur": 0.0,  # Zero cost basis for received assets
                    "timestamp": timestamp,
                    "refid": refid,
                    "year": year,
                })
            
            else:
                # Handle any other transaction types
                row_base[1] = f"Ledger ({entry_type.capitalize()})"
                row_base[2] = "Zu prüfen"  # Need manual verification
                row_base[3] = date_str
                row_base[4] = asset
                row_base[5] = abs(amount)
                row_base[6] = "N/A"
                row_base[7] = price_eur
                row_base[8] = "N/A"
                row_base[9] = 0.0
                row_base[10] = 0.0
                row_base[11] = 0.0
                row_base[12] = fee
                row_base[13] = 0.0
                row_base[14] = 0
                row_base[15] = "Zu prüfen"
                row_base[16] = "Manuelle Überprüfung erforderlich"
                row_base[17] = f"Ledger Ref: {refid} | Unbekannter Transaktionstyp"
            
            # Assign transaction ID
            tx_id = assign_transaction_id(entry_type.upper(), timestamp, asset, amount)
            row_base[17] += f" | ID: {tx_id}"
            
            tax_data.append(row_base)
            line_num += 1
            processed_refids.add(refid)

    # Return the tax data for further processing
    return tax_data
